package com.artoria;

import java.io.IOException;

import org.opencv.core.Core;
import org.opencv.core.CvType;
import org.opencv.core.Mat;
import org.opencv.core.Rect;
import org.opencv.core.Size;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

import net.sourceforge.tess4j.TesseractException;

public class OpenTest {

    static {
        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
        // 注意程序运行的时候需要在VM option添加该行 指明opencv的dll文件所在路径
        // -Djava.library.path=$PROJECT_DIR$\opencv\x64
    }

    /**
     * @param args
     * @throws IOException
     * @throws TesseractException 
     */
    public static void main(String[] args) throws IOException, TesseractException {
        // 读取图片
        Mat grayMat = Imgcodecs.imread("D:/4.jpg");
        Mat dstImage = new Mat();
        // 图片置灰 输出到dstImage
        Imgproc.cvtColor(grayMat, dstImage, Imgproc.COLOR_BGR2GRAY, 0);
        // 输出置灰图片
        Imgcodecs.imwrite("D:/123.jpg", dstImage);

        // 图片二值化处理
        Mat binaryMat = new Mat(dstImage.height(), dstImage.width(), CvType.CV_8UC1);
        // 选取30 200.0 为阈值
        Imgproc.threshold(dstImage, binaryMat, 30, 200.0, Imgproc.THRESH_BINARY);
        // 输出二值化图片
        Imgcodecs.imwrite("D:/234.jpg", binaryMat);

        // 腐蚀图片
        Mat destMat = new Mat();
        // 用3*3的图片去腐蚀
        Mat element = Imgproc.getStructuringElement(Imgproc.MORPH_RECT, new Size(3, 3));
        Imgproc.erode(binaryMat, destMat, element);
        // 输出腐蚀图片
        Imgcodecs.imwrite("D:/345.jpg", destMat);

        // 通过计算像素点获取截取长宽
        int state = 0, a = 0, b = 0;
        for (int y = 0; y < destMat.height(); y++) {
            int count = 0;
            for (int x = 0; x < destMat.width(); x++) {
                // 得到该行像素点的值
                byte[] data = new byte[1];
                destMat.get(y, x, data);
                if (data[0] == 0)
                    count = count + 1;
            }
            if (state == 0) // 还未到有效行
            {
                if (count >= 130) // 找到了有效行
                {// 有效行允许130个像素点的噪声
                    a = y;
                    state = 1;
                }
            } else if (state == 1) {
                if (count <= 130) // 找到了有效行
                {// 有效行允许130个像素点的噪声
                    b = y;
                    state = 2;
                }
            }
        }
        System.out.println("过滤下界" + Integer.toString(a));
        System.out.println("过滤上界" + Integer.toString(b));

        // 参数,坐标X,坐标Y,截图宽度,截图长度 x=0 y=开始截取行位置 宽度为图片宽短 截取长度为上下界相减  生成截取图片坐标
        Rect roi = new Rect(0, a, destMat.width(), b - a);
        //将原图截取坐标大小
        Mat re = destMat.submat(roi);
        //输出截取后图片
        Imgcodecs.imwrite("D:/456.jpg", re);
    }
}
